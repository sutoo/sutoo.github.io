<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Imoko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Imoko">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Imoko">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Imoko">
  
    <link rel="alternate" href="/atom.xml" title="Imoko" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Imoko</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hotspot_jvm_GC_CMS" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/hotspot_jvm_GC_CMS/" class="article-date">
  <time datetime="2018-12-04T13:42:07.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/hotspot_jvm_GC_CMS/">hotspot_jvm_GC_CMS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CMS</p>
<p>CMS全称 <code>Concurrent Mark Sweep</code>，是一款并发的、使用标记-清除算法的垃圾回收器.</p>
<p>JVM 中,老年代的gc可以使用CMS.</p>
<h2 id="触发点"><a href="#触发点" class="headerlink" title="触发点"></a>触发点</h2><p>1 周期性触发</p>
<p>2 条件性触发</p>
<ul>
<li>老年代使用率达到阈值 </li>
<li>新生代的晋升担保失败</li>
</ul>
<p>主要是上面两个,还有其他情况暂不考虑.</p>
<h2 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h2><p>CMS是一种优化的mark-sweep算法,mark-sweep的核心是对象树的遍历, 面临的问题是这个数非常的巨大.但还是基于简单的图的遍历算法:三色标记法.</p>
<blockquote>
<p>对象在标记过程中，根据标记情况，分成三类：</p>
<ol>
<li>白色对象，表示自身未被标记；</li>
<li>灰色对象，表示自身被标记，但内部引用未被处理；</li>
<li>黑色对象，表示自身被标记，内部引用都被处理；</li>
</ol>
</blockquote>
<h5 id="Phase-1-InitialMarking（初始化标记，整个过程STW）"><a href="#Phase-1-InitialMarking（初始化标记，整个过程STW）" class="headerlink" title="Phase 1: InitialMarking（初始化标记，整个过程STW）"></a>Phase 1: InitialMarking（初始化标记，整个过程STW）</h5><p>该阶段单线程执行，主要分分为两步：</p>
<ol>
<li>标记GC Roots可达的老年代对象；</li>
<li>遍历新生代对象，标记可达的老年代对象；</li>
</ol>
<p>标记结束后,如下图:</p>
<p><img src="/Users/sutao/blog/source/_posts/hotspot-jvm-GC/700.png" alt="img"></p>
<h5 id="Phase-2-Marking（并发标记）"><a href="#Phase-2-Marking（并发标记）" class="headerlink" title="Phase 2: Marking（并发标记）"></a>Phase 2: Marking（并发标记）</h5><p>该阶段GC线程和应用线程并发执行，遍历InitialMarking阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。</p>
<p>因为该阶段并发执行的，在运行期间可能发生</p>
<ul>
<li>新生代的对象晋升到老年代、</li>
<li>或者是直接在老年代分配对象、</li>
<li>或者更新老年代对象的引用关系等等.</li>
</ul>
<p>对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。</p>
<p>为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些<strong><em>Dirty Card</em></strong>的对象，避免扫描整个老年代。</p>
<p><img src="/Users/sutao/blog/source/_posts/hotspot-jvm-GC/701.png" alt="img"></p>
<h5 id="Phase-3-Concurrent-Preclean-预清理"><a href="#Phase-3-Concurrent-Preclean-预清理" class="headerlink" title="Phase 3: Concurrent Preclean 预清理"></a>Phase 3: Concurrent Preclean 预清理</h5><p> This is again a concurrent phase, running in parallel with the application threads, not stopping them. While the previous phase was running concurrently with the application, some references were changed. Whenever that happens, the JVM marks the area of the heap (called “Card”) that contains the mutated object as “dirty” (this is known as <a href="http://psy-lob-saw.blogspot.com.ee/2014/10/the-jvm-write-barrier-card-marking.html" target="_blank" rel="noopener">Card Marking</a>). </p>
<p>总的来说, 这个阶段是一个<code>并行</code>的<code>标记</code>过程.</p>
<p>主要目的:减轻Final remark的执行时间.</p>
<p>主要做两件事情：</p>
<ol>
<li>处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象。</li>
<li>在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty（其实这里并非使用CardTable，而是一个类似的数据结构，叫ModUnionTalble），通过扫描这些Table，重新标记那些在并发标记阶段引用被更新的对象（晋升到老年代的对象、原本就在老年代的对象）.  Dirty card 会被清理干净,当这个card中的对象的可达对象都被标记之后.如下面三个图:</li>
</ol>
<p><img src="/Users/sutao/blog/source/_posts/hotspot-jvm-GC/g1-07.png" alt="CMS concurrent marking"></p>
<p><img src="/Users/sutao/blog/source/_posts/hotspot-jvm-GC/g1-08.png" alt="CMS dirty cards"></p>
<p><img src="/Users/sutao/blog/source/_posts/hotspot-jvm-GC/g1-09.png" alt="CMS concurrent preclean"></p>
<p>##### </p>
<h5 id="Phase-4-Concurrent-Abortable-Preclean-可中断的预清理"><a href="#Phase-4-Concurrent-Abortable-Preclean-可中断的预清理" class="headerlink" title="Phase 4: Concurrent Abortable Preclean 可中断的预清理"></a>Phase 4: Concurrent Abortable Preclean 可中断的预清理</h5><p>又是一个<code>并行</code>的<code>标记</code>过程.</p>
<p>主要目的: 减轻Final Remark 的执行时间.</p>
<p>该阶段发生的前提是，新生代Eden区的内存使用量大于参数<code>CMSScheduleRemarkEdenSizeThreshold</code> 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。</p>
<p>在该阶段，主要循环的做两件事：</p>
<ol>
<li>处理 From 和 To 区的对象，标记可达的老年代对象</li>
<li>和上一个阶段一样，扫描处理Dirty Card中的对象</li>
</ol>
<p>当然了，这个逻辑不会一直循环下去，打断这个循环的条件有三个：</p>
<ol>
<li>可以设置最多循环的次数 <code>CMSMaxAbortablePrecleanLoops</code>，默认是0，意思没有循环次数的限制。</li>
<li>如果执行这个逻辑的时间达到了阈值<code>CMSMaxAbortablePrecleanTime</code>，默认是5s，会退出循环。</li>
<li>如果新生代Eden区的内存使用率达到了阈值<code>CMSScheduleRemarkEdenPenetration</code>，默认50%，会退出循环。（这个条件能够成立的前提是，在进行Precleaning时，Eden区的使用率小于十分之一）</li>
</ol>
<p>如果在循环退出之前，发生了一次YGC，对于后面的Remark阶段来说，大大减轻了扫描年轻代的负担，但是发生YGC并非人为控制，所以只能祈祷这5s内可以来一次YGC。</p>
<h5 id="Phase-5-Final-Remark-STW"><a href="#Phase-5-Final-Remark-STW" class="headerlink" title="Phase 5: Final Remark (STW)"></a>Phase 5: Final Remark (STW)</h5><p>这是第二个会STW的步骤,也是最后一个.这个步骤的目的是标记Old Generation中的所有存活对象. 因为之前的<code>标记</code>步骤都是和用户线程并发进行的,所以需要一个STW来确保所有的存活对象不会被误回收.</p>
<p>进行如下的处理：</p>
<ol>
<li>遍历新生代对象，重新标记</li>
<li>根据GC Roots，重新标记</li>
<li>遍历老年代的Dirty Card，重新标记，这里的Dirty Card大部分已经在clean阶段处理过</li>
</ol>
<p>之所以要在之前进行Phase 3,4,主要原因是为了减少标记的时间,虽然在phase5中还是要从ROOT扫描全部,但是已经标记过的对象就会快速跳过.</p>
<h5 id="Phase-6-Concurrent-Sweep"><a href="#Phase-6-Concurrent-Sweep" class="headerlink" title="Phase 6: Concurrent Sweep"></a>Phase 6: Concurrent Sweep</h5><p>清理垃圾对象，这个阶段GC线程和用户线程并发执行。</p>
<h5 id="Phase-7-Concurrent-Reset"><a href="#Phase-7-Concurrent-Reset" class="headerlink" title="Phase 7: Concurrent Reset"></a>Phase 7: Concurrent Reset</h5><p>重置CMS收集器的数据结构，做好下一次执行GC任务的准备工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/hotspot_jvm_GC_CMS/" data-id="cjpbgxpxd000ty8fyfldzx2ea" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-GC_overview" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/GC_overview/" class="article-date">
  <time datetime="2018-11-22T10:33:01.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/GC_overview/">GC_overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Garbage Collection</p>
<h1 id="Copying-Garbage-Collection"><a href="#Copying-Garbage-Collection" class="headerlink" title="Copying Garbage Collection"></a>Copying Garbage Collection</h1><p>简单来说,内存分为2个区域,使用其中一个区域分配内存,直到剩余内存不足,则触发GC:遍历所有的ROOT,将可达的对象copy到另外一块内存区域中.</p>
<p>好处: 内存分配相当的快,只是指针的移动.</p>
<p>坏处: 浪费内存.</p>
<p>#Mark and Sweep Garbage Collection</p>
<p>sweep: 扫除; 打扫，清理; </p>
<p>标记，清理垃圾回收</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void GC()</span><br><span class="line">&#123;</span><br><span class="line">    HaltAllProcessing();</span><br><span class="line">    // 枚举root</span><br><span class="line">    ObjectCollection roots = GetRoots();</span><br><span class="line">    for(int i = 0; i &lt; roots.Count(); ++i)</span><br><span class="line">        //标记</span><br><span class="line">        Mark(roots[i]);</span><br><span class="line">    //清理</span><br><span class="line">    Sweep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##枚举root</p>
<p>遍历这些地方的所有reference : registers, global or static fields, local variables on the stack, function arguments on stack。</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>利用每个对象的header中的marked flag，进行标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Mark(Object* pObj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!Marked(pObj)) // Marked returns the marked flag from object header</span><br><span class="line">    &#123;</span><br><span class="line">        MarkBit(pObj); // Marks the flag in obj header</span><br><span class="line"></span><br><span class="line">        // Get list of references that the current object has</span><br><span class="line">        // and recursively mark them as well</span><br><span class="line">        ObjectCollection children = pObj-&gt;GetChildren();</span><br><span class="line">        for(int i = 0; i &lt; children.Count(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Mark(children[i]); // recursively call mark</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用递归的方法进行标记。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>通过遍历整个内存并释放未标记的内存块来开始扫描。它还会清除标记位，以便后续GC通过可以正确标记/取消标记它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Sweep()</span><br><span class="line">&#123;</span><br><span class="line">	//遍历整个内存</span><br><span class="line">    Object *pHeap = pHeapStart;</span><br><span class="line">    while(pHeap &lt; pHeapEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!Marked(pHeap))</span><br><span class="line">            Free(pHeap); // put it to the free object list</span><br><span class="line">        else</span><br><span class="line">            UnMarkBit(pHeap);</span><br><span class="line">        pHeap = GetNext(pHeap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>长期的进行GC，可能会导致内存碎片。回收后的压缩能减少碎片，但是，当内存被压缩时，对象会移动，因此必须更新对它们的所有引用以指向新位置。</p>
<h2 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h2><p>垃圾回收面对的是一个非常巨大的对象树，之前的Mark-sweep伪代码中，使用递归的方法，容易引起stack overflow。</p>
<p>我们可以用一个MarkStack来代替递归，然后使用广度优先来遍历，来尽量避免overflow。但是如果溢出还是不能完全避免，如果发生了溢出，可以采取一些fallbakc 方法：</p>
<ul>
<li><p><strong>Overflow stack</strong></p>
<p>我们会有另外一个stack，叫overflow stack。如果mark steack 满了，object会被塞入overflow stack，并且暂时不去遍历它的孩子节点。</p>
</li>
<li><p><strong>Overflow-arena</strong> </p>
<p>对于overflow stack 都overflow的情况，使用一个链表保存溢出的对象。</p>
</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：可以处理循环引用，而且对平时的处理没有额外的开销（相对引用计数而言）</p>
<p>缺点：1 stw </p>
<pre><code>2 需要遍历整个内存
</code></pre><p> 对这两个缺点，Mark-sweep算法也有很多优化的版本，如JVM的 CMS。</p>
<h1 id="Generational-Garbage-Collection"><a href="#Generational-Garbage-Collection" class="headerlink" title="Generational Garbage Collection"></a>Generational Garbage Collection</h1><p>分代垃圾收集的思想是基于基本的垃圾回收算法之上的.</p>
<p>上面提到的一个mark-sweep的一个重要缺点就是会导致系统暂停。用于解决该问题的主要优化方法之一是采用<code>分代垃圾收集</code>。分代垃圾收集基于以下几个特点:</p>
<ul>
<li>大部分对象在很年轻的时候就死了</li>
<li>GC中回收的对象有90%是在上次GC之后创建的</li>
<li>如果一个对象在一次GC中存活, 它在短期内变成垃圾的概率很低</li>
</ul>
<p>一种常见的方法是将新创建的对象视为在第0代（Gen0）中，然后如果它没有被垃圾收集循环收集，则将其提升到下一个更高代的Gen1. 更频繁地收集较低代. 这可确保降低系统暂停时间. 触发较高代的集合的次数较少. 使用了多少代，因系统而异. 在.NET中使用了3代。为简单起见，我们将考虑使用2代系统，但概念很容易扩展到2代以上. </p>
<h2 id="高代到低代的引用"><a href="#高代到低代的引用" class="headerlink" title="高代到低代的引用"></a>高代到低代的引用</h2><p>分代垃圾回收器(Generational garbage collectors)需要跟踪 <code>老年代-&gt;年轻代</code>的引用, 以便在对<code>年轻代</code>回收时, 不用去遍历<code>老年代</code>的所有对象.</p>
<p><strong><em>为什么只用考虑老年代中指向了年轻代的引用?</em></strong></p>
<p>因为年轻代的内存次数远大于老年代, 且老年代的内存空间一般会更大.并且经过统计信息显示，老年代持有新生代对象引用的情况不足1%.其实在对老年代GC的时候,也是需要考虑年轻代中的对老年代中对象的引用.</p>
<h3 id="Write-Barrier定义"><a href="#Write-Barrier定义" class="headerlink" title="Write Barrier定义"></a>Write Barrier定义</h3><p>如果store操作把一个老年代的引用指向了一个新的object(一般在年轻代中),系统必须保证这个位置被记录到remember set中, 这种机制,通常被叫做 <code>write barrier</code> 或者 <code>store check</code></p>
<p>在非函数式语言中, store操作是很频繁的,所以一个高效的<code>write barrier</code>实现是很必要的.</p>
<p><code>card marking</code> 是<code>write barrier</code>的一种实现.</p>
<h3 id="card-marking实现"><a href="#card-marking实现" class="headerlink" title="card marking实现"></a>card marking实现</h3><p>堆被划分为固定大小的<code>card</code>,每个<code>card</code>都关联到一个bit vector中的一个bit. store操作如果改变了这个card中内容,对应的bit会被设置.在垃圾收集时，收集器扫描bit vector，每当找到标记位时，检查对应的堆中相应card中的所有指针。</p>
<h3 id="HotSpot中的Write-barrier"><a href="#HotSpot中的Write-barrier" class="headerlink" title="HotSpot中的Write barrier"></a>HotSpot中的Write barrier</h3><ul>
<li><p>dirty card</p>
<p>card marking方式</p>
</li>
<li><p>SATB</p>
<p>snapshot-at-the-beginning, 被G1收集器采用.</p>
</li>
</ul>
<p>###write barrier + card-table</p>
<p>首先创建一个称为卡表(card-table)的表。这本质上是一个位数组。每个位指示给定范围的内存是否脏（包含对较低生成对象的写入）。例如。我们可以使用单个位来标记4KB块。</p>
<p><img src="/Users/sutao/blog/source/_posts/JVM-generational-GC/image_thumb_7.png" alt="image_thumb_7"></p>
<p>第一次标记仅针对Gen0对象。一旦结束，它会检查卡表以找到Gen1中的脏块。然后，它将该脏块中的每个<strong>对象</strong>视为新根，并使用它标记对象。 </p>
<p><img src="/Users/sutao/blog/source/_posts/JVM-generational-GC/image_thumb.png" alt="image_thumb"></p>
<p>##参考链接</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/GC_overview/" data-id="cjpbgxpw90009y8fy2xsxibcb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java_synchronizer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/Java_synchronizer/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/Java_synchronizer/">JVM Synchronizer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#JVM synchronizer    </p>
<h4 id="SafePoint"><a href="#SafePoint" class="headerlink" title="SafePoint"></a>SafePoint</h4><p>避免程序长时间运行而不进入safepoint</p>
<h4 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h4><p>markword是java对象数据结构中的一部分。</p>
<p>markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的<strong>最后2bit是锁状态标志位</strong>，用来标记当前对象的状态</p>
<p><img src="image-20180905033426190.png" alt="image-20180905033426190"></p>
<h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起。下图大概表明了SMP的结构：</p>
<p><img src="411087_1311836022idIz.png" alt="411087_1311836022idIz"></p>
<p>其意思是所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>CAS的全称为Compare-And-Swap，是一条CPU的原子指令。Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。</p>
<p>全局安全点</p>
<h3 id="偏向锁-Biased-Locking"><a href="#偏向锁-Biased-Locking" class="headerlink" title="偏向锁(Biased Locking)"></a>偏向锁(Biased Locking)</h3><p>偏向锁就是为了消除CAS，消除无竞争情况下的同步原语，即轻量锁的CAS。</p>
<p>它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p>
<p>就是说如果同一时间只有一个线程来获取锁的话，是满足偏向锁的条件的</p>
<p>问题1 ：偏向锁什么时候升级为轻量锁，怎么升级</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/Java_synchronizer/" data-id="cjpbgxpwj000iy8fyhtb65bz7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BTreeStruct" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/BTreeStruct/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/BTreeStruct/">B-tree数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>btree的go实现：<a href="https://github.com/sutoo/btree/blob/master/btree.go" target="_blank" rel="noopener">https://github.com/sutoo/btree/blob/master/btree.go</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item represents a single object in the tree.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Less tests whether the current item is less than the given argument.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This must provide a strict weak ordering.</span></span><br><span class="line">	<span class="comment">// If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (i.e. we can only</span></span><br><span class="line">	<span class="comment">// hold one of either a or b in the tree).</span></span><br><span class="line">	Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> items []Item</span><br><span class="line"><span class="comment">// children stores child nodes in a node.</span></span><br><span class="line"><span class="keyword">type</span> children []*node</span><br><span class="line"></span><br><span class="line"><span class="comment">// node is an internal node in a tree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It must at all times maintain the invariant that either</span></span><br><span class="line"><span class="comment">//   * len(children) == 0, len(items) unconstrained</span></span><br><span class="line"><span class="comment">//   * len(children) == len(items) + 1</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	items    items</span><br><span class="line">	children children</span><br><span class="line">	cow      *copyOnWriteContext</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BTree is an implementation of a B-Tree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// BTree stores Item instances in an ordered structure, allowing easy insertion,</span></span><br><span class="line"><span class="comment">// removal, and iteration.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write operations are not safe for concurrent mutation by multiple</span></span><br><span class="line"><span class="comment">// goroutines, but Read operations are.</span></span><br><span class="line"><span class="keyword">type</span> BTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	degree <span class="keyword">int</span></span><br><span class="line">	length <span class="keyword">int</span></span><br><span class="line">	root   *node</span><br><span class="line">	cow    *copyOnWriteContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>node是Btree中的一个节点。</p>
<p>items 表示key的列表， items中的gap对应一个children node。</p>
<p>###BTree Struct</p>
<h4 id="方法介绍："><a href="#方法介绍：" class="headerlink" title="方法介绍："></a>方法介绍：</h4><p><code>maxItems</code> degree * 2 -1 ，每个node中，items的最大值。</p>
<p><code>minItems</code>degree - 1，node中，items的最小值。</p>
<p>###Btree and B+tree</p>
<p>Btree:</p>
<p><img src="image-20180913183329671.png" alt="image-20180913183329671"></p>
<p>B+tree:</p>
<p><img src="image-20180913183401336.png" alt="image-20180913183401336"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/BTreeStruct/" data-id="cjpbgxpvv0001y8fyevotyrzk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DBs_mysql_locks" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/DBs_mysql_locks/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/DBs_mysql_locks/">Mysql Locks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###transaction locks</p>
<p>维护在不同的Isolation level下数据库的<strong>Atomicity</strong>和<strong>Consistency</strong>两大基本特性。</p>
<ul>
<li><p><strong>table locks</strong></p>
<p>对整个表加锁，影响所有记录。通常用在DDL语句中，如DELETE TABLE,ALTER TABLE等。</p>
</li>
<li><p><strong>row locks</strong></p>
<p>对一行记录加锁，只影响一条记录。通常用在DML语句中，如INSERT, UPDATE, DELETE等。</p>
</li>
</ul>
<p>InnoDB定义了如下的lock mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic lock modes */</span></span><br><span class="line"><span class="keyword">enum</span> lock_mode &#123;</span><br><span class="line">LOCK_IS = <span class="number">0</span>,     <span class="comment">/* intention shared */</span></span><br><span class="line">LOCK_IX,     <span class="comment">/* intention exclusive */</span></span><br><span class="line">LOCK_S,          <span class="comment">/* shared */</span></span><br><span class="line">LOCK_X,          <span class="comment">/* exclusive */</span></span><br><span class="line">LOCK_AUTO_INC,     <span class="comment">/* locks the auto-inc counter of a table</span></span><br><span class="line"><span class="comment">......</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>shared lock （S) 容许获得锁的事务去 读一行</p>
</li>
<li><p>exclusive lock （X) 容许获得锁的事务去更新或者删除一行</p>
</li>
<li><p>Intention shared （IS）  获取IS表示事务希望获取S锁（或更高）。在获取这一行的S锁之前，需要先获取表的IS</p>
</li>
<li><p>Intention exclusive （IX） 获取IX表示事务希望获取X锁。在获取这一行的X锁之前，需要先获取表的IX。</p>
</li>
</ul>
<p>####lock type compatibility：</p>
<p><img src="image-20180912002757181.png" alt="image-20180912002757181"></p>
<p>####解释：</p>
<p>S，X锁，就像是读写锁，S是读锁，X是写锁。（注：S锁只有<code>IN SHARE MODE</code>才会加。一般的select是consistent read）。在给一行记录加锁前，首先要给该表加意向锁。</p>
<p>####意向锁的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The main purpose of intention locks is to show that someone is locking a row, or going to lock a row in the table.</span><br></pre></td></tr></table></figure>
<p>为方便检测table lock 和 row lock之间的冲突，引入了意向锁。 </p>
<p>当再向一个表添加表级X锁的时候</p>
<ul>
<li>如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突</li>
<li>如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果</li>
</ul>
<p>###内存锁</p>
<p> 为了维护内存结构的一致性，比如Dictionary cache、sync array、trx system等结构。 InnoDB并没有直接使用glibc提供的库，而是自己封装了两类：</p>
<ol>
<li>一类是mutex，实现内存结构的串行化访问</li>
<li>一类是rw lock，实现读写阻塞，读读并发的访问的读写锁</li>
</ol>
<p>###Row Level Lock 细分</p>
<p>####Record Locks </p>
<p>在index records上的锁。比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c1 = <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>这个就为c1 = 10的这个索引加了锁，防止其他事物对所有c1=10的行做inserting, updating,deleting操作。</p>
<h4 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h4><p>是一种在index records之间的一种锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c1 <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>阻止其他事物向c1 的10～20区间内，<strong>插入</strong>数据。（只有插入）</p>
<p>在gap lock锁定的范围内，可以有0～n个index records。</p>
<p>gap lock 是在性能和一致性上的一个折衷，只在某些事物隔离级别下生效。</p>
<p>特点：</p>
<p>1 使用unique index来查单条的语句不会用到gap lock</p>
<p>2 gap lock之间不会有冲突，X-gap lock 和S-gap lock没什么区别。</p>
<p>3 gap lock只是为了防止向一个区间内插入</p>
<h4 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h4><p>是record lock 和gap lock的组合：当前index record 的 record lock + 当前index record之前的区域的 gap lock。</p>
<p>举例：index record为10，11，13，20，则next-key lock可以有以下几种可能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">By default, InnoDB operates in REPEATABLE READ transaction isolation level. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows</span><br></pre></td></tr></table></figure>
<p>InnoDB使用next-key locks 来防止幻读。</p>
<p>幻读，就是在一个事物内，两次select，第二次得到了一个新的row。</p>
<p>所以在锁住当前记录的同事，要把他到前一个记录的‘gap’也锁住。才能保证。不会出现新的纪录。</p>
<h4 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h4><p>//TODO</p>
<h4 id="AUTO-INC-Locks"><a href="#AUTO-INC-Locks" class="headerlink" title="AUTO-INC Locks"></a>AUTO-INC Locks</h4><p>是一个table level的锁，当传入有AUTO_INCREMENT列的字段的时候。如果一个事物在插入几条记录，其他事物也想插入时，必须等待。否则第一个事物就无法获取到连续的自增值。当然，自增序列的顺序的可预见性和插入的并发性能，也是一个权衡的点，可以通过<code>innodb_autoinc_lock_mode</code>来设置。</p>
<p>具体参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html</a></p>
<p>###</p>
<p>###Transaction Isolation Levels</p>
<p>事物隔离级别，是ACID中的I。</p>
<p>前置知识：</p>
<p>Consistent Reads： 无锁的select，（plain select）,MVCC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time.</span><br></pre></td></tr></table></figure>
<p>Locking Reads：<code>SELECT</code> with <code>FOR UPDATE</code> or <code>FOR SHARE</code>, <code>UPDATE</code>, and <code>DELETE</code> statements</p>
<h4 id="Repeatalbe-Read"><a href="#Repeatalbe-Read" class="headerlink" title="Repeatalbe Read"></a>Repeatalbe Read</h4><p>innoDB默认隔离级别。</p>
<ul>
<li>Consistent Reads，即无锁的select，读的都是事物中第一个select得到的snapshot。</li>
<li>Locking Reads <ul>
<li>使用了唯一索引：只有record lock</li>
<li>没使用惟一索引：使用next-key lock 锁住区间。</li>
</ul>
</li>
</ul>
<h4 id="Read-Commited"><a href="#Read-Commited" class="headerlink" title="Read Commited"></a>Read Commited</h4><ul>
<li><p>Consistent Reads：每一个select（即使在同一个事物内）都是一个新的snapshot。</p>
</li>
<li><p>Locking Reads：只上Record lock，无gap lock或next-lock</p>
</li>
</ul>
<p>所以，<code>幻读</code>出现。</p>
<p>####READ UNCOMMITTED</p>
<h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h4><h3 id="Locks-Set-by-Different-SQL-Statements-in-InnoDB"><a href="#Locks-Set-by-Different-SQL-Statements-in-InnoDB" class="headerlink" title="Locks Set by Different SQL Statements in InnoDB"></a>Locks Set by Different SQL Statements in InnoDB</h3><ul>
<li><code>Select ... from...</code>是consistent read,读一个snapshot。除非是SERIALIZABLE隔离级别，这个时候，设置shared next-key lock。</li>
<li><code>select ... for update</code> 和 <code>select ... for share</code>会加X next-key lock。如果是唯一索引，会加<code>record lock</code>。</li>
<li><code>Update...where..</code>会加 X next-key lock。如果是唯一索引，会加<code>record lock</code>。</li>
<li><code>delete from ... where</code>加X next-key lock。如果是唯一索引，会加<code>record lock</code>。</li>
<li><code>insert</code>会给当前插入的行加<code>record lock</code>。</li>
</ul>
<p>参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html</a></p>
<h3 id="Consistent-Reads"><a href="#Consistent-Reads" class="headerlink" title="Consistent Reads"></a>Consistent Reads</h3><p>consistent reads的含义是InnodB使用multi-versioning去给查询提供一个数据库的snapshot。查询只能看到这个点之前提交的事物的改动，而对之后的一无所知。</p>
<p>Consistent read is the default mode in which <code>InnoDB</code> processes <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> statements in <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>and <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener"><code>REPEATABLE READ</code></a> isolation levels.</p>
<p> A consistent read does not set any locks on the tables it accesses,</p>
<p>If you want to see the “freshest” state of the database, use either the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a> isolation level or a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">locking read</a>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">FOR</span> <span class="keyword">SHARE</span>;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html</a></p>
<h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><p>Undo Log是为了实现事务的<strong>原子性</strong>，在MySQL数据库InnoDB存储引擎中，还用UndoLog来实现多版本并发控制(简称：MVCC)。 -事务的原子性(Atomicity) 事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</p>
<p>参考：<a href="https://www.cnblogs.com/kongzhongqijing/articles/7905051.html" target="_blank" rel="noopener">https://www.cnblogs.com/kongzhongqijing/articles/7905051.html</a></p>
<h3 id="Redo"><a href="#Redo" class="headerlink" title="Redo"></a>Redo</h3><p>记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，<br>但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>
<p>InnoDB有<code>buffer pool</code>（简称bp）。bp是数据库页面的缓存，对InnoDB的任何修改操作都会首先在bp的page上进行，然后这样的页面将被标记为dirty并被放到专门的flush list上，后续将由master thread或专门的刷脏线程阶段性的将这些页面写入磁盘（disk or ssd）。这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的修改merge成一次IO操作，同时异步写入也降低了访问的时延。然而，如果在dirty page还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是redo log file。这样的技术推迟了bp页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写redo log操作的开销（顺序IO，当然很快），以及数据库启动时恢复操作所需的时间。</p>
<p>redo log包括两部分：</p>
<ul>
<li>一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；</li>
<li>二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</li>
</ul>
<p>在概念上，innodb通过<strong>force log at commit</strong>机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>
<p>为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。</p>
<p>也就是说，从redo log buffer写日志到磁盘的redo log file中，过程如下：</p>
<p><img src="733013-20180508101949424-938931340.png" alt="733013-20180508101949424-938931340"></p>
<p>MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。</p>
<ul>
<li>当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</li>
<li>当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li>
<li>当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。</li>
</ul>
<p><img src="733013-20180508104623183-690986409.png" alt="733013-20180508104623183-690986409"></p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</a></p>
<p><a href="https://www.cnblogs.com/kongzhongqijing/articles/7905051.html" target="_blank" rel="noopener">https://www.cnblogs.com/kongzhongqijing/articles/7905051.html</a></p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本，这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本随意修改，各个事务之间无干扰</li>
<li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li>
</ul>
<p>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，而Innodb的实现方式是：</p>
<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
<p>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p>
<p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p>
<p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p>
<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/DBs_mysql_locks/" data-id="cjpbgxpx4000py8fyvkdaaovz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-consul-simple" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/consul-simple/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/consul-simple/">Consul简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><strong>10,000 foot view</strong></p>
<p><img src="consul-arch-420ce04a.png" alt="consul-arch-420ce04a"></p>
<ul>
<li>Agent </li>
</ul>
<p>Agent是在consul集群上一直运行的后台进程，通过 “consul agent” 启动，可以以两种方式运行：客户端，服务器。上图的每个长方形就是一个Agent。</p>
<ul>
<li>Client </li>
</ul>
<p>表示Agentl的客户端模式（紫色方块）。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是<strong>不持久化</strong>这些信息。</p>
<ul>
<li>Server</li>
</ul>
<p>SERVER表示consul的服务器模式（红色方块）。表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息<strong>持久化</strong>的本地，这样遇到故障，信息是可以被保留的。</p>
<ul>
<li>Server-Leader</li>
</ul>
<p>它和其它SERVER不一样的一点是（红色方块，带LEADER字样的），它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。</p>
<ul>
<li><p>DateCenter</p>
<p>在consul中，datacenter被定义为：私有，低延迟，高带宽。所以不会跨公网的情况。</p>
</li>
</ul>
<h4 id="server-和client"><a href="#server-和client" class="headerlink" title="server 和client"></a>server 和client</h4><p>还是看下上面的图， 图中有2个数据中心。consul是支持</p>
<pre><code>**多数据中心**
</code></pre><p>的。每个DataCenter 包含多个 server 和client， 但是server 可能只有 3到5个，多了的话可能会变慢。因为server间要保持一致性。client没有这样的限制，他们可以成千上万。</p>
<h4 id="LAN-Gossip-Pool"><a href="#LAN-Gossip-Pool" class="headerlink" title="LAN Gossip Pool"></a>LAN Gossip Pool</h4><p>数据中心中所有的节点，都在一个 gossip protocol中，有2个目的：</p>
<p>1 新增的节点可以被自动发现。</p>
<p>2 失效节点的检测是分布式的。（这里可以看下gossip的实现）</p>
<h4 id="server-leader-的特殊职责"><a href="#server-leader-的特殊职责" class="headerlink" title="server-leader 的特殊职责"></a>server-leader 的特殊职责</h4><p>leader负责处理所有请求和事务。非leader的sercer收到rpc请求的时候，会把它转给leader。</p>
<h4 id="WAN-gossip-pool"><a href="#WAN-gossip-pool" class="headerlink" title="WAN gossip pool"></a>WAN gossip pool</h4><p>所有DataCenter的server同时也是WAN gossip pool的一部分。与LAN Gossip Pool不同的是： 对公网的高延迟做了优化。</p>
<p>带来的好处：DataCenter之间可以互相发现，新增一个DateCenter会很简单，join进来就可以。</p>
<pre><code>同时支持了跨DC的RPC调用，在 failure detection，connection cache，multiplexing等技术的应用，跨DC的调用也不是很慢。
</code></pre><p>问题： 跨DC调用是可以的，但是数据可能是按DC分片的，怎么解决？</p>
<p>答： There are some special situations where a limited subset of data can be replicated, such as with Consul’s built-in <a href="https://www.consul.io/docs/guides/acl.html#outages-and-acl-replication" target="_blank" rel="noopener">ACL replication</a> capability, or external tools like <a href="https://github.com/hashicorp/consul-replicate" target="_blank" rel="noopener">consul-replicate</a>.</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><h4 id="Raft-in-Consul"><a href="#Raft-in-Consul" class="headerlink" title="Raft in Consul"></a>Raft in Consul</h4><p>只有server节点参与Raft。</p>
<p>Raft 主要被分成了<code>领导人选举</code>，<code>日志复制</code>和<code>安全</code>三个模块</p>
<ul>
<li><strong>领导选举</strong>：一个新的领导人需要被选举出来，当现存的领导人宕机的时候</li>
<li><strong>日志复制</strong>：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。</li>
<li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。 </li>
</ul>
<p>任期在 Raft 算法中充当逻辑时钟的作用</p>
<p>两种类型的 RPCs。</p>
<ul>
<li>请求投票（RequestVote） RPCs 由候选人在选举期间发起 ，</li>
<li>然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制</li>
</ul>
<p>领导者周期性的向所有跟随者发送心跳包来维持自己的权威</p>
<p>###复制状态机</p>
<p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p>保证复制日志相同就是一致性算法的工作了。</p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/consul-simple/" data-id="cjpbgxpwm000ny8fyk5tyzyb1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM_gc_cms" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JVM_gc_cms/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JVM_gc_cms/">JVM GC CMS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#CMS</p>
<p>全称 <code>Concurrent Mark Sweep</code></p>
<p>本质是标记-清除算法，针对老年代的GC。进行了改进，缩短了STW的时间。</p>
<p>阶段：</p>
<ul>
<li><p>初始标记 <strong>Initial Mark</strong>（STW）</p>
<p>标记GC ROOT和年轻代对象能<strong>直接关联</strong>到的对象。</p>
<p><img src="/images/g1-06.png" alt="CMS initial mark"></p>
</li>
<li><p>并发标记</p>
<p>由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。 GC线程和用户线程并发执行。Old代不是所有存活对象会被标记</p>
</li>
<li><p>并发预清理 <strong>Concurrent Preclean</strong></p>
<p>JVM将包含变异对象的堆区域（称为“Card”）标记为“脏”</p>
<p><img src="g1-08.png" alt="g1-08"></p>
</li>
<li><p><strong>Concurrent Abortable Preclean</strong></p>
<p>？？</p>
</li>
<li><p><strong>Final Remark </strong>（STW）</p>
<p>最终标记所有的老年代的存活对象。</p>
</li>
<li><p><strong>Concurrent Sweep</strong></p>
<p>删除未标记的对象并回收它们占用的空间。</p>
</li>
</ul>
<p>###安全点（safepoint）</p>
<p>程序只有在运行到安全点的时候，才可以暂停下来。<code>HotSpot</code>采用主动中断的方式，让执行线程在运行期轮询是否需要暂停的标志，若需要则中断挂起。</p>
<h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><p>1.本身是根对象。根（root）是指由堆以外空间访问的对象。JVM会将以下对象标记为根：</p>
<p>a.虚拟机栈（栈帧中的本地变量表）中引用的对象；</p>
<p>b.方法区中的类静态属性引用的对象；</p>
<p>c.方法区中的常量引用的对象；</p>
<p>d.本地方法栈中JNI的引用对象。</p>
<p>2.被一个可达的对象引用。</p>
<p>参考：<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JVM_gc_cms/" data-id="cjpbgxpwh000fy8fyaw4h9v7q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/hystrix/" class="article-date">
  <time datetime="2018-11-22T06:24:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/hystrix/">Hystrix简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>## </p>
<h2 id="Command模式解决什么问题"><a href="#Command模式解决什么问题" class="headerlink" title="Command模式解决什么问题"></a>Command模式解决什么问题</h2><p>What solution does the Command design pattern describe?</p>
<ul>
<li>Define separate (command) objects that encapsulate a request.</li>
<li>A class delegates a request to a command object instead of implementing a particular request directly.</li>
</ul>
<p>What problems can the Command design pattern solve?  </p>
<ul>
<li>Coupling the invoker of a request to a particular request should be avoided. That is, hard-wired requests should be avoided.</li>
<li>It should be possible to configure an object (that invokes a request) with a request.</li>
</ul>
<p>Implementing (hard-wiring) a request directly into a class is inflexible because it couples the class to a particular request at compile-time, which makes it impossible to specify a request at run-time.</p>
<p>总结：Hystrix的command模式带来的好处是在运行时，可以动态切换对某个client的方法的实现。（fallback）</p>
<h2 id="Hystrix的设计原则"><a href="#Hystrix的设计原则" class="headerlink" title="Hystrix的设计原则"></a>Hystrix的设计原则</h2><ul>
<li>防止任何单个依赖项用尽所有容器（例如Tomcat）用户线程。</li>
<li>甩负荷（Shedding load）并快速失败而不是排队。</li>
<li>在可行的地方提供fallback以保护用户免于失败。</li>
<li>使用隔离技术来限制任何一个依赖项的影响。</li>
<li>通过近实时指标，监控和警报优化问题发现时间。</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="hystrix-command-flow-chart.png" alt="hystrix-command-flow-chart"></p>
<p>有4种方式可以执行一个command：</p>
<ul>
<li><p>同步执行</p>
<p>execute()— 阻塞式调用，返回一个单个的response。当调用execute()实际上会调用queue().get()</p>
</li>
<li><p>异步执行</p>
<p>queue() — 返回一个Future，用这个Future可以获取一个单个的response。实际会调用toObservable().toBlocking().toFuture()</p>
</li>
<li><p>响应式执行（hot）</p>
<p>observe()— 返回一个Observable，并且立刻订阅。 实际会调用 toObservable().subscribe(subject)</p>
</li>
<li><p>响应式执行 （cold）</p>
<p>toObservable()— 返回一个Observable，当被订阅的时候，才开始执行指令。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K             value   = command.execute();</span><br><span class="line">Future&lt;K&gt;     fValue  = command.queue();</span><br><span class="line">Observable&lt;K&gt; ohValue = command.observe();         <span class="comment">//hot observable</span></span><br><span class="line">Observable&lt;K&gt; ocValue = command.toObservable();    <span class="comment">//cold observable</span></span><br></pre></td></tr></table></figure>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul>
<li>同步执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span> <span class="comment">//execute()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span> <span class="comment">//queue()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">getUserByIdAsync</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>响应式执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>（observableExecutionMode = EAGER）<span class="comment">//observable()</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>（observableExecutionMode = LAZY）<span class="comment">//toObservable()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUserById</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;User&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> User&gt; observer)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                            observer.onNext(<span class="keyword">new</span> User(id, name + id));</span><br><span class="line">                            observer.onCompleted();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        observer.onError(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><h3 id="Thread-pool"><a href="#Thread-pool" class="headerlink" title="Thread pool"></a>Thread pool</h3><p>好处：安全，能够将client看作黑盒。</p>
<p>坏处：耗时增加，每一个command的执行都要经历queueing, scheduling和线程切换。</p>
<h3 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h3><p>好处：没有额外的消耗</p>
<p>坏处：因为无法主动中断，必须完全相信client能够快速失败。</p>
<h2 id="Sequence-Diagram"><a href="#Sequence-Diagram" class="headerlink" title="Sequence Diagram"></a>Sequence Diagram</h2><p>@adrianb11 has kindly provided a <a href="https://design.codelytics.io/hystrix/how-it-works" target="_blank" rel="noopener">sequence diagram</a> demonstrating the above flows</p>
<h2 id="Hystrix-参数调整"><a href="#Hystrix-参数调整" class="headerlink" title="Hystrix 参数调整"></a>Hystrix 参数调整</h2><p><img src="thread-configuration-1280.png" alt="thread-configuration-1280"></p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><ul>
<li><p>用接近99.5线的值来设置Thread Timeout。</p>
</li>
<li><p>如果容许重试的话，Thread Timeout和NetworkTimeout要配合起来，留够一次retry的时间：</p>
<pre><code>ThreadTimeout &gt;（NetworkTimeOut + retry的预估用时）
</code></pre></li>
<li><p>NetworkTimeout的一般被设置为在网络层可以拦截最耗时的1%的请求。</p>
</li>
</ul>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><ul>
<li>线程池大小 = 每秒请求数*99线的响应时间（以秒为单位）</li>
</ul>
<p>queued + poolSize = 并发数</p>
<p>队列过长，会导致响应时间增加。</p>
<p>Hystrxi的treahdpool的配置和java的线程池一样。</p>
<p>Metrix</p>
<p>Metric</p>
<h2 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h2><p>参考：</p>
<p><a href="https://blog.csdn.net/xiaojia1100/article/details/65631778" target="_blank" rel="noopener">https://blog.csdn.net/xiaojia1100/article/details/65631778</a></p>
<p><a href="https://en.wikipedia.org/wiki/Command_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Command_pattern</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/hystrix/" data-id="cjpbgxpxe000uy8fyv3gp27p7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Observable_basic" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/Observable_basic/" class="article-date">
  <time datetime="2018-11-08T16:00:00.000Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/09/Observable_basic/">ReactiveX基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Observable基础：</p>
<p>基本的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">// cover for generics insanity</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给Observable的onSubscribe赋值了我们定义的OnSubscribe对象</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//subscribe这个函数做了什么事?</span></span><br><span class="line">    <span class="comment">//调用Observable中的OnSubscribe对象的call方法，以下面的Subscriber对象作为参数。</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"rx"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/09/Observable_basic/" data-id="cjpbgxpwl000ly8fy4htv0qcw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Histograms" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/Histograms/" class="article-date">
  <time datetime="2018-11-08T16:00:00.000Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/09/Histograms/">Histograms</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A <code>Histogram</code> measures the distribution of values in a stream of data</p>
<p>直方图描述数据流中的数据分布情况。</p>
<p>直方图不仅仅能提供最大，最小，平均值，而且可以提供median（中位线）或者99th线。</p>
<p>计算直方图的基本方法：排序。但是对吞吐量大，低延迟要求的系统，不适用。下面介绍下常用的方法。</p>
<h2 id="dropwizard"><a href="#dropwizard" class="headerlink" title="dropwizard"></a>dropwizard</h2><p>一个开源的Metrics库，<a href="https://metrics.dropwizard.io/3.2.3/manual/core.html#exponentially-decaying-reservoirs。采用了下面的方法来统计Histogram。" target="_blank" rel="noopener">https://metrics.dropwizard.io/3.2.3/manual/core.html#exponentially-decaying-reservoirs。采用了下面的方法来统计Histogram。</a></p>
<h3 id="reservoir-sampling-（蓄水池采样）"><a href="#reservoir-sampling-（蓄水池采样）" class="headerlink" title="reservoir sampling （蓄水池采样）"></a>reservoir sampling （蓄水池采样）</h3><blockquote>
<p>在一个给定长度的数组中随机等概率抽取一个数据很容易，但如果面对的是长度未知的海量数据流呢？蓄水池采样(Reservoir Sampling)算法就是来解决这个问题的, 它在分析一些大数据集的时候非常有用。 </p>
<p>先把读到的前k个对象放入“水库”，对于第k+1个对象开始，以k/(k+1)的概率选择该对象，以k/(k+2)的概率选择第k+2个对象，以此类推，以k/m的概率选择第m个对象（m&gt;k）。如果m被选中，则随机替换水库中的一个对象。最终每个对象被选中的概率均为k/n，证明如下</p>
<p>第m个对象被选中的概率=选择m的概率 x（其后元素不被选择的概率+其后元素被选择的概率 x 不替换第m个对象的概率），即</p>
<p><img src="1338455236_7354.png" alt="1338455236_7354"></p>
</blockquote>
<ul>
<li><p>Uniform Reservoirs</p>
<p>统计全量数据，通过 <a href="http://www.cs.umd.edu/~samir/498/vitter.pdf" target="_blank" rel="noopener">Vitter’s R</a>算法，来随机选取数据。用于长时间的测量。</p>
</li>
<li><p>Exponentially Decaying Reservoirs</p>
<p>只看最后5分钟的数据，通过使用 <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf" target="_blank" rel="noopener">forward-decaying priority reservoir</a>来对新数据进行指数加权。不像Uniform Reservoirs，它只展示最近的数据，可以让你尽早的发现数据的变化</p>
</li>
<li><p>Sliding Window Reservoirs</p>
<p>只关注最后N个</p>
</li>
<li><p>Sliding Time Window Reservoirs</p>
<p>只关注最后N秒内</p>
</li>
</ul>
<blockquote>
<p>SlidingTimeWindowReservoirs 因为它是无界的，如果被用在一个大吞吐量的系统，会造成大量的内存浪费，因为它记录每一个measurement，所以也是最慢的。</p>
</blockquote>
<p>但是看到了这篇文章：<a href="https://medium.com/hotels-com-technology/your-latency-metrics-could-be-misleading-you-how-hdrhistogram-can-help-9d545b598374" target="_blank" rel="noopener">https://medium.com/hotels-com-technology/your-latency-metrics-could-be-misleading-you-how-hdrhistogram-can-help-9d545b598374</a></p>
<blockquote>
<p>Dropwizard内部默认使用Exponentially decaying Reservoirs （EDR）</p>
<p>但是有以下缺点：</p>
<ul>
<li>EDR设计有损;它们不存储每个样本（它们具有统计学上的代表性）。</li>
<li>默认情况下，EDR存储静态1028个样本，并且样本在过去5分钟内被加权。 </li>
<li>EDR中样本衰减的速率受直方图更新频率的影响。</li>
</ul>
<p>这些缺点加起来意味着您报告的指标可能会产生误导，要么是由于丢弃的样本导致的不准确，要么是通过包含可能更旧的样本来计算的。虽然提供代替方案，但都不适合实时报告。</p>
<p>HdrHistogram（高动态范围直方图）是一种无损直方图实现，具有可配置的值精度，可解决EDR的缺点。 </p>
</blockquote>
<h2 id="HdrHistogram"><a href="#HdrHistogram" class="headerlink" title="HdrHistogram"></a>HdrHistogram</h2><p>//TODO</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/09/Histograms/" data-id="cjpbgxpwf000dy8fyrjk3eldp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GC/" style="font-size: 20px;">GC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/04/hotspot_jvm_GC_CMS/">hotspot_jvm_GC_CMS</a>
          </li>
        
          <li>
            <a href="/2018/11/22/GC_overview/">GC_overview</a>
          </li>
        
          <li>
            <a href="/2018/11/22/Java_synchronizer/">JVM Synchronizer</a>
          </li>
        
          <li>
            <a href="/2018/11/22/BTreeStruct/">B-tree数据结构</a>
          </li>
        
          <li>
            <a href="/2018/11/22/DBs_mysql_locks/">Mysql Locks</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Tao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>